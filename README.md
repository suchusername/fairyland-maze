Решение задания отборочного этапа олимпиады "Волга-IT'22" по дисциплине "Прикладное программирование на C++".

Автор: Прохоров Юрий

# Установка и запуск

Выкачать репозиторий:
```
git clone https://github.com/suchusername/fairyland-maze.git
```
Перейти в директорию с проектом. Создать папку, в которой будет лежать сборка:
```
cd fairyland-maze
mkdir build
```
В этой папке сконфигурировать проект через `cmake`, а затем собрать его:
```
cmake . -DCMAKE_BUILD_TYPE=Release -Bbuild
cmake --build build
```
Из корня репозитория запустить исполняемый файл:
```
./build/fairyland_go
```

# Описание решения

## Структура проекта

Я использую структуру проекта, более-менее стандартную для сборки с помощью `cmake`:
- В папке `fairytale` лежат файлы `include/fairytale/fairy_tail.hpp` и `src/fairy_tail.cpp`, предоставленные организаторами. Этот код обособлен в библиотеку `fairytale`, которую я подключаю к своему коду.
- В папке `include` лежит header-файл `fairyland/fairyland.h` для библиотеки `fairyland`, которая содержит почти весь мой код.
- В папке `src` лежат файлы `dfs.cpp`, `combine_maps.cpp` и `forest_map.cpp`, имплементирующие функции из header'а библиотеки.
- Также в папке `src` лежит файл `main.cpp`, который компилируется в исполняемый файл `fairyland_go`.

### Замечание

Чтобы мой проект имел одну единую структуру, мне пришлось сделать следующее:
- Я изменил путь к файлу `input.txt`, так как исполняемый файл при моей сборке оказывается в директории `/build`. Мне хотелось отделить автогенерируемые файлы от исходного кода и входа программы.
- Я изменил `#include "fairy_tail.hpp"` на `#include <fairytale/fairy_tail.hpp>`, так я разнес header и имплементацию по разным папкам.
- Прогнал `clang-format`, чтобы весь проект был в одном стиле.

Никаких изменений в файлах `fairy_tail.*`, влияющих на исполнение программы, я не делал.

## Описание алгоритма

Мое решение делает следующее:
- если Иван и Елена могут встретиться, то он организовывает их встречу за 250 ходов, а если они не могут встретиться, то сообщает об этом (**пункты 1 и 2**)
- строит _наиболее полную_ карту местности, которую Иван и Елена могут получить (**пункт 3**)
- в алгоритме экземпляр класса `Fairyland` создается только один раз

**Алгоритм**:
1. Первые 200 шагов Иван и Елена тратят на исследование лабиринта.

   Иван и Елена параллельно идут по лабиринту согласно поиску в глубину (Depth First Search, DFS). Ребра, по которым идет DFS, образуют дерево, причем по каждому ребру DFS идет ровно 2 раза (в одну сторону, а потом обратно). В нашем лабиринте 100 клеток, значит в дереве DFS 99 ребер (число ребер в дереве равно числу вершин минус 1). Значит, на полный обход достижимой части лабиринта Ивану и Елене требуется **не более 198 ходов**. Для удобства я округлил до 200 ходов. 

2. Проверяется, получили ли Иван и Елена одинаковые карты.

   Если Иван и Елена могут встретиться, то карты, которые они получат при обходе лабиринта, будут одинаковыми. 
  
   Если карты разные:
   - встреча Ивана и Елены невозможна
  
   Если карты одинаковые:
   - вычисляются координаты Елены относительно Ивана
   - находится кратчайший путь от Ивана к Елене
   
     Кратчайший путь от Ивана к Елене ищется с помощью поиска в ширину (Breadth First Search, BFS). Так как в лабиринте 100 клеток, то любой кратчайший путь между иметь длину не более 99 ребер. Пусть Иван и Елена идут навстречу друг другу. Тогда они гарантированно встретятся за **не более, чем 50 ходов**, если их встреча возможна.
     
   - Иван и Елена тратят не более 50 шагов на движение навстречу друг другу по кратчайшему пути
   
     Если за эти ходы они встретились:
     - встреча Ивана и Елены организована за не более, чем 250 шагов

     Если за эти ходы они не встретились:
     - встреча Ивана и Елены невозможна

3. Строится карта лабиринта.

   Так как сначала Иван и Елена делают полный обход лабиринта, то у есть возможность построить наиболее полную карту лабиринта. Для этого надо объединить карты Ивана и Елены.
   
   Если Иван и Елена встретились:
   - карта лабиринта равна карте Ивана

     (потому что карты Ивана и Елена одинаковые)
     
   Если Иван и Елена не встретились:
   - мы сливаем карты Ивана и Елена так, чтобы они не пересекались


## Описание имплементации

Документация к интерфейсам, предоставленным в файле `include/fairyland/fairyland.h`.

#### `class DepthFirstSearch`

Этот класс отвечает за движение персонажей по лабиринту на 1 шаге алгоритма. В этом классе я спрашиваю у лабиринта (у класса `Fairyland`), куда персонаж может пойти, но персонажа не двигаю. Функция `DepthFirstSearch::get_move()` возвращает действие, которое надо выполнить персонажу, чтобы обновить лабиринт.

Функция `DepthFirstSearch::get_map_copy()` возвращает карту `ForestMap`, которую смог построить персонаж к текущему моменту.

Имплементация методов этого класса находится в файле `src/dfs.cpp`.

#### `class ForestMap`

Эта сущность - карта персонажа после исследования лабиринта. Так как персонаж не знает, где он находится, то это карта имеет размер 21 на 21, и персонаж думает, что он находится в середине этой карты (в точке `(0, 0)`). Координаты карты: от -10 до 10 включительно по каждой из осей.

У карты есть методы `ForestMap::smallest_known_x()`, ..., которые нужны, чтобы описать прямоугольник вокруг разведанной части карты.

Метод `ForestMap::get_subgrid_copy()` возвращает подматрицу карты.

Имплементация методов этого класса находится в файле `src/forest_map.cpp`.

#### `find_offset_between_equal_maps()`

Эта функция пытается наложить карты Ивана и Елены друг на друга, перебирая все возможные сдвиги. Если карты Ивана и Елены одинаковые, то этот сдвиг единственный, и он равен потенциальным координатам Елены относительно Ивана.

Если карты разные (то есть не существует такого сдвига), то функция вернет `std::nullopt`.

Имплементирована в `src/combine_maps.cpp`.

#### `write_second_map_onto_first()`

Эта функция совмещает модифицирует карту Ивана, записывая на нее карту Елены. 

Если Иван и Елена встретитись (их карты одинаковые):
- в функцию передаются координаты Елены относительно Ивана
- на карту Ивана наносятся положения Ивана (в точку `(0, 0)`) и Елены (согласно данным координатам)

Если Иван и Елена не могут встретиться:
- в качестве координат Елены передается `std::nullopt`
- перебираются все возможные координаты Елены и выбираются такие, чтобы карты Ивана и Елены не пересекались (такие всегда существуют)
- на карту Ивана переносится информация с карты Елены согласно найденному сдвигу
- на карту Ивана наносятся положения Ивана (в точку `(0, 0)`) и Елены (согласно найденному сдвигу)

Имплементация в `src/combine_maps.cpp`.

#### `crop_map()`

Эта функция вырезает из карты 21 на 21 кусочек размера 10 на 10, содержащий все известные клетки. Этот кусочек всегда существует.

Имплементация в `src/combine_maps.cpp`.

  
